From 8e3eeb7688b7169cdd7d7395135b0f46a66d3aa8 Mon Sep 17 00:00:00 2001
From: Shunsuke Mie <mie@igel.co.jp>
Date: Mon, 14 Aug 2023 13:47:10 +0900
Subject: [PATCH 1/2] hw/misc: add qemu pci endpoint controller device

Signed-off-by: Shunsuke Mie <mie@igel.co.jp>
---
 hw/misc/Kconfig         |   4 +
 hw/misc/meson.build     |   2 +
 hw/misc/qemu-epc-comm.c | 531 +++++++++++++++++++++++++++++++
 hw/misc/qemu-epc-comm.h | 159 ++++++++++
 hw/misc/qemu-epc.c      | 686 ++++++++++++++++++++++++++++++++++++++++
 include/hw/pci/pci.h    |   1 +
 6 files changed, 1383 insertions(+)
 create mode 100644 hw/misc/qemu-epc-comm.c
 create mode 100644 hw/misc/qemu-epc-comm.h
 create mode 100644 hw/misc/qemu-epc.c

diff --git a/hw/misc/Kconfig b/hw/misc/Kconfig
index cc8a8c1418ff..755c473788e4 100644
--- a/hw/misc/Kconfig
+++ b/hw/misc/Kconfig
@@ -200,4 +200,8 @@ config IOSB
 config XLNX_VERSAL_TRNG
     bool
 
+config QEMU_EPC
+    default y if PCI_DEVICES
+    bool
+
 source macio/Kconfig
diff --git a/hw/misc/meson.build b/hw/misc/meson.build
index 36c20d5637f7..36f996b1b25f 100644
--- a/hw/misc/meson.build
+++ b/hw/misc/meson.build
@@ -152,5 +152,7 @@ specific_ss.add(when: 'CONFIG_MIPS_ITU', if_true: files('mips_itu.c'))
 
 system_ss.add(when: 'CONFIG_SBSA_REF', if_true: files('sbsa_ec.c'))
 
+system_ss.add(when: 'CONFIG_QEMU_EPC', if_true: files('qemu-epc.c', 'qemu-epc-comm.c'))
+
 # HPPA devices
 system_ss.add(when: 'CONFIG_LASI', if_true: files('lasi.c'))
diff --git a/hw/misc/qemu-epc-comm.c b/hw/misc/qemu-epc-comm.c
new file mode 100644
index 000000000000..ea51ca8058ba
--- /dev/null
+++ b/hw/misc/qemu-epc-comm.c
@@ -0,0 +1,531 @@
+/*
+ * A implementation of protocol between QEMU PCI Endpoint
+ * Controller(EPC) and Endpoint device emulation.
+ *
+ * The endpoint device emulator works as a server and, the QEMU PCI EPC connect
+ * to them.
+ */
+
+#include "qemu-epc-comm.h"
+#include "qemu/log.h"
+
+int qemu_epc_comm_start_server(int *srv_fd)
+{
+    struct sockaddr_un sun;
+    socklen_t socklen;
+    int err;
+    int fd;
+
+    fd = socket(AF_UNIX, SOCK_STREAM, 0);
+    if (fd < 0) {
+        return -1;
+    }
+
+    sun.sun_family = AF_UNIX;
+    strcpy(sun.sun_path, QEMU_EPC_SOCK_PATH);
+
+    err = bind(fd, (const struct sockaddr *)&sun, sizeof(sun));
+    if (err == -1) {
+        return -1;
+    }
+
+    err = listen(fd, 1);
+    if (err == -1) {
+        return -1;
+    }
+
+    *srv_fd = fd;
+
+    socklen = sizeof(sun);
+
+    return accept(fd, (struct sockaddr *)&sun, &socklen);
+}
+
+void qemu_epc_comm_shutdown_server(int clt_fd, int srv_fd)
+{
+    close(clt_fd);
+    close(srv_fd);
+}
+
+int qemu_epc_comm_recv_msg(int fd, struct qemu_epc_msg_hdr *hdr)
+{
+    ssize_t size;
+
+    size = recv(fd, hdr, sizeof(*hdr), 0);
+    if (size != sizeof(*hdr)) {
+        qemu_log("%s: invalid: %ld != %ld\n", __func__, size, sizeof(*hdr));
+        return -1;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_check_protcol_ver(int fd)
+{
+    struct qemu_epc_msg_hdr emsg = {
+        .type = QEMU_EPC_MSG_TYPE_VER,
+    };
+    ssize_t size;
+    uint32_t ver;
+
+    size = send(fd, &emsg, sizeof(emsg), 0);
+    if (size != sizeof(emsg)) {
+        return -1;
+    }
+
+    size = recv(fd, &ver, sizeof(ver), 0);
+    if (size != sizeof(ver)) {
+        return -1;
+    }
+
+    return !(ver == QEMU_EPC_PROTOCOL_VER);
+}
+
+int qemu_epc_comm_resp_protocol_ver(int fd)
+{
+    uint32_t ver = QEMU_EPC_PROTOCOL_VER;
+    ssize_t size;
+
+    size = send(fd, &ver, sizeof(ver), 0);
+
+    return size != sizeof(ver);
+}
+
+int qemu_epc_comm_pass_fd(int dfd, int fd)
+{
+    struct msghdr msg = { 0 };
+    char buf[CMSG_SPACE(sizeof(fd))] = {0};
+    ssize_t size;
+    /*
+     * In order to send the ancillary data, we have to send payload at least on
+     * byte.
+     */
+    char iobuf[1];
+    struct iovec io = { .iov_base = iobuf, .iov_len = sizeof(iobuf) };
+
+    struct qemu_epc_msg_hdr emsg = {
+        .type = QEMU_EPC_MSG_TYPE_PASS_FD,
+    };
+
+    size = send(dfd, &emsg, sizeof(emsg), 0);
+    if (size != sizeof(emsg)) {
+        return -1;
+    }
+
+    msg.msg_iov = &io;
+    msg.msg_iovlen = 1;
+    msg.msg_control = buf;
+    msg.msg_controllen = sizeof(buf);
+
+    struct cmsghdr *cmsg = CMSG_FIRSTHDR(&msg);
+    cmsg->cmsg_level = SOL_SOCKET;
+    cmsg->cmsg_type = SCM_RIGHTS;
+    cmsg->cmsg_len = CMSG_LEN(sizeof(fd));
+
+    *((typeof(fd) *) CMSG_DATA(cmsg)) = fd;
+
+    msg.msg_controllen = CMSG_SPACE(sizeof(fd));
+
+    size = sendmsg(dfd, &msg, 0);
+
+    return !(size == sizeof(iobuf));
+}
+
+int qemu_epc_comm_recv_fd(int rfd)
+{
+    ssize_t size;
+    char inbuf[1];
+    struct iovec iov = {inbuf, sizeof(inbuf)};
+    char cmsg[CMSG_SPACE(sizeof(int))];
+    struct msghdr msg = {
+        .msg_name = NULL,
+        .msg_namelen = 0,
+        .msg_iov = &iov,
+        .msg_iovlen = 1,
+        .msg_control = cmsg,
+        .msg_controllen = sizeof(cmsg),
+        .msg_flags = 0
+    };
+    struct cmsghdr *cmsghdr;
+
+    size = recvmsg(rfd, &msg, 0);
+    if (size < 0) {
+        return -1;
+    }
+
+    cmsghdr = CMSG_FIRSTHDR(&msg);
+
+    return *(int *)CMSG_DATA(cmsghdr);
+}
+
+int qemu_epc_comm_req_bar(int fd, int idx, struct pci_bar *bar)
+{
+    struct qemu_epc_msg_hdr emsg = {
+        .type = QEMU_EPC_MSG_TYPE_REQ_BAR,
+        .bar.idx = idx,
+    };
+    ssize_t size;
+
+    size = send(fd, &emsg, sizeof(emsg), 0);
+    if (size != sizeof(emsg)) {
+        return -1;
+    }
+
+    size = recv(fd, bar, sizeof(*bar), 0);
+    if (size != sizeof(*bar)) {
+        return -1;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_resp_bar(int fd, struct pci_bar *bar)
+{
+    ssize_t size;
+
+    size = send(fd, bar, sizeof(*bar), 0);
+    if (size != sizeof(*bar)) {
+        return -1;
+    }
+
+    return 0;
+};
+
+int qemu_epc_comm_comp_with_data(int fd, void *buf, size_t length)
+{
+    struct pci_tlp_comp tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_CPLD,
+        .dw0.length = length >> 2,
+    };
+    ssize_t size;
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        return -1;
+    }
+
+    size = send(fd, buf, length, 0);
+    if (size != length) {
+        return -1;
+    }
+
+    return 0;
+}
+
+static int _qemu_epc_comm_recv_comp_with_data(int fd, void *buf, size_t length)
+{
+    struct pci_tlp_comp tlp;
+    ssize_t size;
+
+    size = recv(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        return -1;
+    }
+
+    if (tlp.dw0.fmt_type != PCI_TLP_TYPE_CPLD) {
+        return -1;
+    }
+
+    size = recv(fd, buf, length, 0);
+    if (size != length) {
+        return -1;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_recv_tlp(int fd, uint32_t hdr[4])
+{
+    ssize_t size, rvsize;
+    void *ptr;
+    struct pci_tlp_hdr_dw0 *dw0;
+    size = recv(fd, &hdr[0], sizeof(hdr[0]), 0);
+    if (size != sizeof(hdr[0])) {
+        return -1;
+    }
+
+    dw0 = (struct pci_tlp_hdr_dw0 *)&hdr[0];
+    switch (dw0->fmt_type) {
+    case PCI_TLP_TYPE_CR0:
+        size = recv(fd, &hdr[1], sizeof(hdr[1]) * 2, 0);
+        if (size != sizeof(hdr[1]) * 2) {
+            qemu_log("%s:%d receive err 0x%lx != 0x%lx\n", __func__, __LINE__,
+                     size, sizeof(hdr[1]) * 2);
+            return -1;
+        }
+        break;
+    case PCI_TLP_TYPE_MW:
+    case PCI_TLP_TYPE_MR:
+    case PCI_TLP_TYPE_MSG:
+        rvsize = sizeof(hdr[1]) * 3;
+        ptr = &hdr[1];
+        while (1) {
+            size = recv(fd, ptr, rvsize, 0);
+            if (size < 0) {
+                qemu_log("%s:%d receive err: %ld\n", __func__, __LINE__, size);
+                return -1;
+            }
+            rvsize -= size;
+            if (rvsize == 0) {
+                break;
+            }
+
+            ptr += size;
+        }
+        break;
+    default:
+        qemu_log("not supported: %d\n", dw0->fmt_type);
+        return -2;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_get_pci_offset_from_tlp(struct pci_tlp_config *tlp,
+                                          uint32_t *offset)
+{
+    uint32_t off;
+
+    off = (uint32_t)tlp->dw2.reg_num << 2;
+    off |= (uint32_t)tlp->dw2.ext_reg_num << 8;
+
+    *offset = off;
+
+    return 0;
+}
+
+int qemu_epc_comm_config_read(int fd, size_t offset, uint32_t *data)
+{
+    ssize_t size;
+    struct qemu_epc_msg_hdr emsg = {
+        .type = QEMU_EPC_MSG_TYPE_TLP,
+    };
+
+    struct pci_tlp_config tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_CR0,
+        .dw0.length = 1,
+        .dw2.reg_num = (offset & 0xfc) >> 2,
+        .dw2.ext_reg_num = (offset & 0xf00) >> 8,
+    };
+
+    size = send(fd, &emsg, sizeof(emsg), 0);
+    if (size != sizeof(emsg)) {
+        return -1;
+    }
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        return -1;
+    }
+
+    return _qemu_epc_comm_recv_comp_with_data(fd, data, sizeof(*data));
+}
+
+
+size_t qemu_epc_comm_tlp_data_length(struct pci_tlp_hdr_dw0 *dw0)
+{
+    return (size_t)dw0->length << 2;
+}
+
+int qemu_epc_comm_bar_read(int fd, int idx, hwaddr offset, void *data,
+                           size_t length)
+{
+    struct qemu_epc_msg_hdr mhdr = {
+        .type = QEMU_EPC_MSG_TYPE_TLP,
+        .bar.idx = idx,
+    };
+    struct pci_tlp_mem tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_MR,
+        .dw0.length = length >> 2,
+        .dw23.laddr = (uint32_t)offset,
+        .dw23.haddr = offset >> 32,
+    };
+    ssize_t size;
+
+    size = send(fd, &mhdr, sizeof(mhdr), 0);
+    if (size != sizeof(mhdr)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return _qemu_epc_comm_recv_comp_with_data(fd, data, length);
+}
+
+hwaddr qemu_epc_comm_get_pci_addr_from_tlp(struct pci_tlp_mem *tlp)
+{
+    return  (hwaddr)tlp->dw23.haddr << 32 | (hwaddr)tlp->dw23.laddr;
+}
+
+int qemu_epc_comm_bar_write(int fd, int idx, hwaddr offset, void *data,
+                            size_t length)
+{
+    struct qemu_epc_msg_hdr mhdr = {
+        .type = QEMU_EPC_MSG_TYPE_TLP,
+        .bar.idx = idx,
+    };
+    struct pci_tlp_mem tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_MW,
+        .dw0.length = length >> 2,
+        .dw23.laddr = (uint32_t)offset,
+        .dw23.haddr = offset >> 32,
+    };
+    ssize_t size;
+
+    size = send(fd, &mhdr, sizeof(mhdr), 0);
+    if (size != sizeof(mhdr)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, data, length, 0);
+    if (size != length) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_mem_read(int fd, hwaddr pci, void *data, size_t length)
+{
+    struct qemu_epc_msg_hdr mhdr = {
+        .type = QEMU_EPC_MSG_TYPE_TLP,
+    };
+    struct pci_tlp_mem tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_MR,
+        .dw0.length = length >> 2,
+        .dw23.laddr = (uint32_t)pci,
+        .dw23.haddr = pci >> 32,
+    };
+    ssize_t size;
+
+    size = send(fd, &mhdr, sizeof(mhdr), 0);
+    if (size != sizeof(mhdr)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        return -1;
+    }
+
+    return _qemu_epc_comm_recv_comp_with_data(fd, data, length);
+}
+
+int qemu_epc_comm_mem_write(int fd, hwaddr pci, void *data, size_t length)
+{
+    struct qemu_epc_msg_hdr mhdr = {
+        .type = QEMU_EPC_MSG_TYPE_TLP,
+    };
+    struct pci_tlp_mem tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_MW,
+        .dw0.length = length >> 2,
+        .dw23.laddr = (uint32_t)pci,
+        .dw23.haddr = pci >> 32,
+    };
+    ssize_t size;
+
+    size = send(fd, &mhdr, sizeof(mhdr), 0);
+    if (size != sizeof(mhdr)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, data, length, 0);
+    if (size != length) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_load_data(int fd, void *dest, size_t length)
+{
+    ssize_t size;
+
+    size = recv(fd, dest, length, 0);
+    if (size != length) {
+        return -1;
+    }
+
+    return 0;
+}
+
+int qemu_epc_comm_raise_irq(int fd, int intn)
+{
+    struct qemu_epc_msg_hdr mhdr = {
+        .type = QEMU_EPC_MSG_TYPE_TLP,
+    };
+    struct pci_tlp_msg tlp = {
+        .dw0.fmt_type = PCI_TLP_TYPE_MSG,
+    };
+    ssize_t size;
+
+    switch (intn) {
+    case 0:
+        tlp.dw1.msg_code = PCI_TLP_MSG_CODE_ASRT_INTA;
+        break;
+    case 1:
+        tlp.dw1.msg_code = PCI_TLP_MSG_CODE_ASRT_INTB;
+        break;
+    case 2:
+        tlp.dw1.msg_code = PCI_TLP_MSG_CODE_ASRT_INTC;
+        break;
+    case 3:
+        tlp.dw1.msg_code = PCI_TLP_MSG_CODE_ASRT_INTD;
+        break;
+    default:
+        qemu_log("invalid irq number found: %d\n", intn);
+        return -1;
+    }
+
+    size = send(fd, &mhdr, sizeof(mhdr), 0);
+    if (size != sizeof(mhdr)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    size = send(fd, &tlp, sizeof(tlp), 0);
+    if (size != sizeof(tlp)) {
+        qemu_log("%s:%d\n", __func__, __LINE__);
+        return -1;
+    }
+
+    return 0;
+}
+
+enum PCI_TLP_IRQ_NUM qemu_epc_comm_irqn_from_tlp(struct pci_tlp_msg *tlp)
+{
+    switch (tlp->dw1.msg_code) {
+    case PCI_TLP_MSG_CODE_ASRT_INTA:
+        return PCI_TLP_IRQ_INTA;
+    case PCI_TLP_MSG_CODE_ASRT_INTB:
+        return PCI_TLP_IRQ_INTB;
+    case PCI_TLP_MSG_CODE_ASRT_INTC:
+        return PCI_TLP_IRQ_INTC;
+    case PCI_TLP_MSG_CODE_ASRT_INTD:
+        return PCI_TLP_IRQ_INTD;
+    default:
+        return PCI_TLP_IRQ_INVALID;
+    }
+}
diff --git a/hw/misc/qemu-epc-comm.h b/hw/misc/qemu-epc-comm.h
new file mode 100644
index 000000000000..4df04f742477
--- /dev/null
+++ b/hw/misc/qemu-epc-comm.h
@@ -0,0 +1,159 @@
+#ifndef QEMU_EPC_COMM_H
+#define QEMU_EPC_COMM_H
+
+#include "qemu/osdep.h"
+#include "exec/hwaddr.h"
+
+#define QEMU_EPC_SOCK_PATH "/tmp/qemu-epc.sock"
+
+enum QEMU_EPC_MSG_TYPE {
+    QEMU_EPC_MSG_TYPE_VER,
+    QEMU_EPC_MSG_TYPE_PASS_FD,
+    QEMU_EPC_MSG_TYPE_REQ_BAR,
+    QEMU_EPC_MSG_TYPE_IRQ_INFO,
+    QEMU_EPC_MSG_TYPE_TLP,
+};
+
+struct qemu_epc_msg_hdr {
+    uint8_t type;
+    union {
+        struct {
+            uint8_t reserved0;
+            uint16_t reserved1;
+        };
+        struct {
+            uint8_t idx;
+            uint16_t reserved;
+        } bar;
+    };
+} __attribute__((packed));
+
+#define QEMU_EPC_PROTOCOL_VER 0x00000001
+
+int qemu_epc_comm_start_server(int *srv_fd);
+void qemu_epc_comm_shutdown_server(int clt_fd, int srv_fd);
+int qemu_epc_comm_recv_msg(int fd, struct qemu_epc_msg_hdr *hdr);
+
+int qemu_epc_comm_check_protcol_ver(int fd);
+int qemu_epc_comm_resp_protocol_ver(int fd);
+int qemu_epc_comm_pass_fd(int dfd, int fd);
+int qemu_epc_comm_recv_fd(int rfd);
+
+struct pci_bar {
+    uint64_t phys_addr;
+    uint64_t size;
+    uint8_t flags;
+} __attribute__((packed));
+
+int qemu_epc_comm_req_bar(int fd, int idx, struct pci_bar *bar);
+int qemu_epc_comm_resp_bar(int fd, struct pci_bar *bar);
+
+int qemu_epc_comm_req_irq_info(int fd, uint8_t *int_pin);
+int qemu_epc_comm_resp_irq_info(int fd, uint8_t int_pin);
+
+#define PCI_TLP_TYPE_MR     0b00000000
+#define PCI_TLP_TYPE_MRL    0b00000001
+#define PCI_TLP_TYPE_MW     0b01000000
+#define PCI_TLP_TYPE_IOR    0b00000010
+#define PCI_TLP_TYPE_IOW    0b01000010
+#define PCI_TLP_TYPE_CR0    0b00000100
+#define PCI_TLP_TYPE_CW0    0b01000100
+#define PCI_TLP_TYPE_CR1    0b00000101
+#define PCI_TLP_TYPE_CW1    0b01000101
+#define PCI_TLP_TYPE_MSG    0b00110000
+#define PCI_TLP_TYPE_MSGD   0b01110000
+#define PCI_TLP_TYPE_CPL    0b00001010
+#define PCI_TLP_TYPE_CPLD   0b01001010
+#define PCI_TLP_TYPE_CPLLK  0b00001011
+#define PCI_TLP_TYPE_CPLDLK 0b01001011
+#define PCI_TLP_TYPE_FETCHADD   0b01001101
+#define PCI_TLP_TYPE_CAS    0b01001110
+#define PCI_TLP_TYPE_LPRFX  0b10000000
+#define PCI_TLP_TYPE_EPRFX  0b10010000
+
+struct pci_tlp_hdr_dw0 {
+    uint8_t fmt_type;
+    uint8_t tmp;
+    uint8_t tmp2:6;
+    uint16_t length:10;
+} __attribute__((packed));
+
+struct pci_tlp_config {
+    struct pci_tlp_hdr_dw0 dw0;
+    uint32_t dw1;
+    struct {
+        uint8_t bus_num;
+        uint8_t dev_num:4;
+        uint8_t func_num:4;
+        uint8_t rsv1:4;
+        uint8_t ext_reg_num:4;
+        uint8_t reg_num:6;
+        uint8_t rsv0:2;
+    } __attribute__((packed)) dw2;
+} __attribute__((packed));
+
+struct pci_tlp_comp {
+    struct pci_tlp_hdr_dw0 dw0;
+    uint32_t dw1, dw2;
+} __attribute__((packed));
+
+struct pci_tlp_msg {
+    struct pci_tlp_hdr_dw0 dw0;
+    struct {
+        uint16_t req_id;
+        uint8_t tag;
+        uint8_t msg_code;
+    } __attribute__((packed)) dw1;
+    uint32_t dw23[2];
+} __attribute__((packed));
+
+struct pci_tlp_mem {
+    struct pci_tlp_hdr_dw0 dw0;
+    uint32_t dw1;
+    struct {
+        uint32_t haddr;
+        uint32_t laddr;
+    } __attribute__((packed)) dw23;
+} __attribute__((packed));
+
+int qemu_epc_comm_get_pci_offset_from_tlp(struct pci_tlp_config *tlp,
+        uint32_t *offset);
+
+int qemu_epc_comm_recv_tlp(int fd, uint32_t hdr[4]);
+int qemu_epc_comm_config_read(int fd, size_t offset, uint32_t *data);
+int qemu_epc_comm_comp_with_data(int fd, void *buf, size_t length);
+
+hwaddr qemu_epc_comm_get_pci_addr_from_tlp(struct pci_tlp_mem *tlp);
+size_t qemu_epc_comm_tlp_data_length(struct pci_tlp_hdr_dw0 *dw0);
+
+int qemu_epc_comm_bar_read(int fd, int idx, hwaddr offset, void *data,
+        size_t length);
+int qemu_epc_comm_bar_write(int fd, int idx, hwaddr offset, void *data,
+        size_t length);
+int qemu_epc_comm_mem_read(int fd, hwaddr pci, void *data, size_t length);
+int qemu_epc_comm_mem_write(int fd, hwaddr pci, void *data, size_t length);
+
+int qemu_epc_comm_load_data(int fd, void *dest, size_t length);
+
+#define PCI_TLP_MSG_CODE_ASRT_INTA 0b00100000
+#define PCI_TLP_MSG_CODE_ASRT_INTB 0b00100001
+#define PCI_TLP_MSG_CODE_ASRT_INTC 0b00100010
+#define PCI_TLP_MSG_CODE_ASRT_INTD 0b00100011
+#define PCI_TLP_MSG_CODE_DASRT_INTA 0b00100100
+#define PCI_TLP_MSG_CODE_DASRT_INTB 0b00100101
+#define PCI_TLP_MSG_CODE_DASRT_INTC 0b00100110
+#define PCI_TLP_MSG_CODE_DASRT_INTD 0b00100111
+
+int qemu_epc_comm_raise_irq(int fd, int intn);
+
+enum PCI_TLP_IRQ_NUM {
+    PCI_TLP_IRQ_INVALID,
+    PCI_TLP_IRQ_INTA,
+    PCI_TLP_IRQ_INTB,
+    PCI_TLP_IRQ_INTC,
+    PCI_TLP_IRQ_INTD,
+};
+
+enum PCI_TLP_IRQ_NUM qemu_epc_comm_irqn_from_tlp(struct pci_tlp_msg *tlp);
+
+#endif /* QEMU_EPC_COMM_H */
diff --git a/hw/misc/qemu-epc.c b/hw/misc/qemu-epc.c
new file mode 100644
index 000000000000..88f793db9819
--- /dev/null
+++ b/hw/misc/qemu-epc.c
@@ -0,0 +1,686 @@
+/*
+ * QEMU PCI Endpoint Controller device
+ */
+
+#include "qemu/osdep.h"
+#include "qom/object.h"
+#include "hw/pci/pci_device.h"
+
+#include "qemu-epc-comm.h"
+
+#define DEBUG_QEMU_EPC
+#ifdef DEBUG_QEMU_EPC
+#include "qemu/log.h"
+#define qemu_epc_debug(...) qemu_log("QemuEPC: " __VA_ARGS__)
+#else
+#define qemu_epc_debug(...) do {} while (0)
+#endif
+
+#define QEMU_EPC_REVISON 0x00
+
+struct QemuEPCState {
+    /*< private >*/
+    PCIDevice dev;
+
+    /*< public >*/
+    MemoryRegion ctrl_mr, pci_cfg_mr, bar_cfg_mr;
+    MemoryRegion ob_window_mr;
+    uint32_t ob_map_mask;
+    uint32_t ob_idx;
+    struct qemu_epc_ob_map {
+        uint64_t phys;
+        uint64_t pci;
+        uint64_t size;
+    } ob_map[32];
+
+    QemuThread thread;
+
+    int srv_fd, clt_fd;
+    int req_fd;
+
+    uint8_t pcie_cfg_space[PCIE_CONFIG_SPACE_SIZE];
+
+    /* configuration for BAR */
+    struct pci_bar bars[6];
+
+    uint8_t bar_mask;
+    uint8_t bar_no;
+    uint8_t irq_type;
+};
+
+#define TYPE_QEMU_EPC "qemu-epc"
+
+OBJECT_DECLARE_SIMPLE_TYPE(QemuEPCState, QEMU_EPC);
+
+enum {
+    QEMU_EPC_BAR_CTRL = 0,
+    QEMU_EPC_BAR_PCI_CFG = 1,
+    QEMU_EPC_BAR_BAR_CFG = 2,
+    QEMU_EPC_BAR_OB_WINDOW = 3,
+};
+
+#define QEMU_EPC_OB_WINDOW_SIZE 0x100000
+#define QEMU_EPC_NUM_OF_OB_MAPS 0x10
+
+struct qemu_epc_ob_map_reg {
+    uint64_t phys_dddr;
+    uint64_t pci_addr;
+    uint64_t size;
+    uint64_t reserved;
+} __attribute__((packed));
+
+enum {
+    QEMU_EPC_CTRL_OFF_START = 0x00,
+    QEMU_EPC_CTRL_OFF_WIN_START = 0x8,
+    QEMU_EPC_CTRL_OFF_WIN_SIZE = 0x10,
+    QEMU_EPC_CTRL_OFF_IRQ_TYPE = 0x18,
+    QEMU_EPC_CTRL_OFF_IRQ_NUM = 0x1c,
+    QEMU_EPC_CTRL_OFF_OB_MAP_MASK = 0x20,
+    QEMU_EPC_CTRL_OFF_OB_IDX = 0x24,
+    QEMU_EPC_CTRL_OFF_OB_MAP_PHYS = 0x28,
+    QEMU_EPC_CTRL_OFF_OB_MAP_PCI = 0x30,
+    QEMU_EPC_CTRL_OFF_OB_MAP_SIZE = 0x38,
+
+    QEMU_EPC_CTRL_SIZE = QEMU_EPC_CTRL_OFF_OB_MAP_SIZE + sizeof(uint64_t)
+};
+
+static uint64_t qemu_epc_mmio_ctrl_read(void *opaque, hwaddr addr,
+                                        unsigned size)
+{
+    QemuEPCState *s = opaque;
+
+    qemu_epc_debug("CTRL read: addr 0x%lx, size 0x%x\n", addr, size);
+
+    switch (addr) {
+    case QEMU_EPC_CTRL_OFF_WIN_START:
+        return s->ob_window_mr.addr;
+    case QEMU_EPC_CTRL_OFF_WIN_START + sizeof(uint32_t):
+        return s->ob_window_mr.addr >> 32;
+    case QEMU_EPC_CTRL_OFF_WIN_SIZE:
+        return 0x100000;
+    case QEMU_EPC_CTRL_OFF_WIN_SIZE + sizeof(uint32_t):
+        return 0;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_MASK:
+        return s->ob_map_mask;
+    default:
+        qemu_epc_debug("unexpected read found: %ld\n", addr);
+    }
+
+    return 0;
+}
+
+static int qemu_epc_handle_tlp_mr(QemuEPCState *s, int fd,
+                                  struct pci_tlp_mem *tlp,
+                                  struct qemu_epc_msg_hdr *mhdr)
+{
+    int err;
+    size_t offset = qemu_epc_comm_get_pci_addr_from_tlp(tlp);
+    int idx = mhdr->bar.idx;
+    hwaddr addr;
+    size_t length = qemu_epc_comm_tlp_data_length(&tlp->dw0);
+    void *buf;
+
+    addr = s->bars[idx].phys_addr + offset;
+    qemu_log("idx 0x%x, addr 0x%lx, offset 0x%lx, len 0x%lx\n", idx, addr,
+             offset, length);
+
+    buf = pci_dma_map(&s->dev, addr, &length, DMA_DIRECTION_TO_DEVICE);
+
+    qemu_log("%s: 0x%x\n", __func__, *(uint32_t *)buf);
+
+    err = qemu_epc_comm_comp_with_data(fd, buf, length);
+
+    pci_dma_unmap(&s->dev, buf, length, DMA_DIRECTION_TO_DEVICE, length);
+
+    return err;
+}
+
+static int qemu_epc_handle_tlp_mw(QemuEPCState *s, int fd,
+                                  struct pci_tlp_mem *tlp,
+                                  struct qemu_epc_msg_hdr *mhdr)
+{
+    int err;
+    hwaddr addr;
+    void *buf;
+    int idx = mhdr->bar.idx;
+    size_t offset = qemu_epc_comm_get_pci_addr_from_tlp(tlp);
+    size_t length = qemu_epc_comm_tlp_data_length(&tlp->dw0);
+
+    addr = s->bars[idx].phys_addr + offset;
+
+    qemu_log("%s:%d addr 0x%lx, offset 0x%lx, len 0x%lx\n", __func__, __LINE__,
+             addr, offset, length);
+    buf = pci_dma_map(&s->dev, addr, &length, DMA_DIRECTION_FROM_DEVICE);
+
+    err = qemu_epc_comm_load_data(fd, buf, length);
+
+    pci_dma_unmap(&s->dev, buf, length, DMA_DIRECTION_FROM_DEVICE, length);
+
+    return err;
+}
+
+static int qemu_epc_handle_tlp_cr0(QemuEPCState *s, int fd,
+                                   struct pci_tlp_config *tlp)
+{
+    int err;
+    uint32_t offset;
+
+    err = qemu_epc_comm_get_pci_offset_from_tlp(tlp, &offset);
+    if (err) {
+        qemu_epc_debug("%s:%d %d\n", __func__, __LINE__, err);
+        return err;
+    }
+
+    if (offset + 4 >= PCIE_CONFIG_SPACE_SIZE) {
+        return err;
+    }
+
+    qemu_epc_debug("%s:%d off 0x%x, val 0x%x\n", __func__, __LINE__, offset,
+                   *(uint32_t *)(&s->pcie_cfg_space[offset]));
+
+    /* The size of TLP config read is fixed to 4. */
+    return qemu_epc_comm_comp_with_data(fd, &s->pcie_cfg_space[offset], 4);
+}
+
+static int qemu_epc_hande_tlp(QemuEPCState *s, int fd,
+                              struct qemu_epc_msg_hdr *mhdr)
+{
+    int err;
+    uint32_t tlp_hdr[4];
+    struct pci_tlp_hdr_dw0 *dw0;
+
+    err = qemu_epc_comm_recv_tlp(fd, tlp_hdr);
+    if (err) {
+        qemu_epc_debug("%s:%d %d\n", __func__, __LINE__, err);
+        return -1;
+    }
+
+    dw0 = (struct pci_tlp_hdr_dw0 *)&tlp_hdr[0];
+
+    switch (dw0->fmt_type) {
+    case PCI_TLP_TYPE_MR:
+        err = qemu_epc_handle_tlp_mr(s, fd, (struct pci_tlp_mem *)tlp_hdr,
+                                     mhdr);
+        if (err) {
+            qemu_epc_debug("%s:%d %d\n", __func__, __LINE__, err);
+            return -1;
+        }
+        break;
+    case PCI_TLP_TYPE_MW:
+        err = qemu_epc_handle_tlp_mw(s, fd, (struct pci_tlp_mem *)tlp_hdr,
+                                     mhdr);
+        if (err) {
+            qemu_epc_debug("%s:%d %d\n", __func__, __LINE__, err);
+            return -1;
+        }
+        break;
+    case PCI_TLP_TYPE_CR0:
+        err = qemu_epc_handle_tlp_cr0(s, fd,
+                                      (struct pci_tlp_config *)tlp_hdr);
+        if (err) {
+            qemu_epc_debug("%s:%d %d\n", __func__, __LINE__, err);
+            return -1;
+        }
+        break;
+    default:
+        qemu_epc_debug("The fmt type[0x%x] is not supported\n",
+                       dw0->fmt_type);
+        return -1;
+    }
+
+    return 0;
+}
+
+static int qemu_epc_handle_req_bar(QemuEPCState *s, int fd, int idx)
+{
+    if (idx > 5) {
+        return -1;
+    }
+
+    if (s->bar_mask & 1 << idx) {
+        return qemu_epc_comm_resp_bar(fd, &s->bars[idx]);
+    } else {
+        struct pci_bar bar = {};
+        return qemu_epc_comm_resp_bar(fd, &bar);
+    }
+}
+
+static void *qemu_epc_thread(void *opaque)
+{
+    QemuEPCState *s = opaque;
+    int err;
+    int fd;
+    struct qemu_epc_msg_hdr hdr;
+
+    fd = qemu_epc_comm_start_server(&s->srv_fd);
+    if (fd < 0) {
+        qemu_epc_debug("failed to start server\n");
+        return NULL;
+    }
+
+    while (true) {
+        err = qemu_epc_comm_recv_msg(fd, &hdr);
+        if (err) {
+            qemu_epc_debug("failed to receive message from client\n");
+            goto done;
+        }
+
+        switch (hdr.type) {
+        case QEMU_EPC_MSG_TYPE_VER:
+            err = qemu_epc_comm_resp_protocol_ver(fd);
+            if (err) {
+                qemu_epc_debug("Failed to send protocol version\n");
+                goto done;
+            }
+            break;
+        case QEMU_EPC_MSG_TYPE_PASS_FD:
+            s->req_fd = qemu_epc_comm_recv_fd(fd);
+            if (s->req_fd < 0) {
+                qemu_epc_debug("Failed to receive a fd to request\n");
+                goto done;
+            }
+            break;
+        case QEMU_EPC_MSG_TYPE_REQ_BAR:
+            err = qemu_epc_handle_req_bar(s, fd, hdr.bar.idx);
+            if (err) {
+                qemu_epc_debug("Failed to handle requesting bar info\n");
+                goto done;
+            }
+            break;
+        case QEMU_EPC_MSG_TYPE_TLP:
+            err = qemu_epc_hande_tlp(s, fd, &hdr);
+            if (err) {
+                qemu_epc_debug("Failed to handle TLP\n");
+                goto done;
+            }
+            break;
+        default:
+            qemu_epc_debug("receive unknown message type: %d\n", hdr.type);
+            goto done;
+        }
+
+    }
+
+done:
+    qemu_epc_comm_shutdown_server(fd, s->srv_fd);
+
+    return NULL;
+}
+
+static void qemu_epc_handle_ctrl_start(QemuEPCState *s, uint64_t val)
+{
+    qemu_thread_create(&s->thread, "qemu-epc", qemu_epc_thread, s,
+                       QEMU_THREAD_JOINABLE);
+}
+
+static void qemu_epc_handle_ctl_irq(QemuEPCState *s, uint64_t val)
+{
+    int err;
+
+    err = qemu_epc_comm_raise_irq(s->req_fd, val);
+    if (err) {
+        qemu_epc_debug("Failed to raise irq\n");
+    }
+}
+
+static void qemu_epc_mmio_ctrl_write(void *opaque, hwaddr addr, uint64_t val,
+                                     unsigned size)
+{
+    QemuEPCState *s = opaque;
+    uint64_t *tmp;
+
+    qemu_epc_debug("CTRL write: addr 0x%lx, size 0x%x\n", addr, size);
+
+    switch (addr) {
+    case QEMU_EPC_CTRL_OFF_START:
+        qemu_epc_handle_ctrl_start(s, val);
+        return;
+    case QEMU_EPC_CTRL_OFF_IRQ_TYPE:
+        s->irq_type = val;
+        break;
+    case QEMU_EPC_CTRL_OFF_IRQ_NUM:
+        qemu_epc_handle_ctl_irq(s, val);
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_MASK:
+        s->ob_map_mask = val;
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_IDX:
+        s->ob_idx = val;
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_PHYS:
+        tmp = &s->ob_map[s->ob_idx].phys;
+        *tmp = (*tmp & ~0xffffffff) | val;
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_PHYS + sizeof(uint32_t):
+        tmp = &s->ob_map[s->ob_idx].phys;
+        *tmp = (*tmp & 0xffffffff) | (val << 32);
+        qemu_epc_debug("ob map phys: %d: 0x%lx\n", s->ob_idx, *tmp);
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_PCI:
+        tmp = &s->ob_map[s->ob_idx].pci;
+        *tmp = (*tmp & ~0xffffffff) | val;
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_PCI + sizeof(uint32_t):
+        tmp = &s->ob_map[s->ob_idx].pci;
+        *tmp = (*tmp & 0xffffffff) | (val << 32);
+        qemu_epc_debug("ob map pci: %d: 0x%lx\n", s->ob_idx, *tmp);
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_SIZE:
+        tmp = &s->ob_map[s->ob_idx].size;
+        *tmp = (*tmp & ~0xffffffff) | val;
+        break;
+    case QEMU_EPC_CTRL_OFF_OB_MAP_SIZE + sizeof(uint32_t):
+        tmp = &s->ob_map[s->ob_idx].size;
+        *tmp = (*tmp & 0xffffffff) | (val << 32);
+        qemu_epc_debug("ob map size: %d: 0x%lx\n", s->ob_idx, *tmp);
+        break;
+    default:
+        qemu_epc_debug("CTRL write: invalid address 0x%lx\n", addr);
+    }
+}
+
+static const MemoryRegionOps qemu_epc_mmio_ctrl_ops = {
+    .read = qemu_epc_mmio_ctrl_read,
+    .write = qemu_epc_mmio_ctrl_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+};
+
+enum {
+    QEMU_EPC_BAR_CFG_OFF_MASK = 0x00,
+    QEMU_EPC_BAR_CFG_OFF_NUMBER = 0x01,
+    QEMU_EPC_BAR_CFG_OFF_FLAGS = 0x02,
+    QEMU_EPC_BAR_CFG_OFF_RSV = 0x04,
+    QEMU_EPC_BAR_CFG_OFF_PHYS_ADDR = 0x08,
+    QEMU_EPC_BAR_CFG_OFF_SIZE = 0x10,
+
+    QEMU_EPC_BAR_CFG_SIZE = 0x18
+};
+
+static uint64_t qemu_epc_mmio_pci_cfg_read(void *opaque, hwaddr addr,
+                                           unsigned size)
+{
+    uint64_t data;
+    QemuEPCState *s = opaque;
+
+    qemu_epc_debug("PCI cfg read: addr 0x%lx, size 0x%x\n", addr, size);
+
+    if (addr + size > PCIE_CONFIG_SPACE_SIZE) {
+        qemu_epc_debug("PCI cfg write: detect outbounds access: 0x%lx\n",
+                       addr + size);
+        return 0 ;
+    }
+
+    memcpy(&data, &s->pcie_cfg_space[addr], size);
+
+    return data;
+}
+
+static void qemu_epc_mmio_pci_cfg_write(void *opaque, hwaddr addr, uint64_t val,
+                                        unsigned size)
+{
+    QemuEPCState *s = opaque;
+
+    qemu_epc_debug("PCI cfg write: addr 0x%lx, size 0x%x, val 0x%lx\n", addr,
+                   size, val);
+
+    if (addr + size > PCIE_CONFIG_SPACE_SIZE) {
+        qemu_epc_debug("PCI cfg write: detect outbounds access: 0x%lx\n",
+                       addr + size);
+        return;
+    }
+
+    memcpy(&s->pcie_cfg_space[addr], &val, size);
+
+    return;
+}
+
+static const MemoryRegionOps qemu_epc_mmio_pci_cfg_ops = {
+    .read = qemu_epc_mmio_pci_cfg_read,
+    .write = qemu_epc_mmio_pci_cfg_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+};
+
+static uint64_t qemu_epc_mmio_bar_cfg_read(void *opaque, hwaddr addr,
+                                           unsigned size)
+{
+    QemuEPCState *s = opaque;
+
+    qemu_epc_debug("BAR cfg read: addr 0x%lx, size 0x%x\n", addr, size);
+
+    switch (addr) {
+    case QEMU_EPC_BAR_CFG_OFF_MASK:
+        return s->bar_mask;
+    case QEMU_EPC_BAR_CFG_OFF_NUMBER:
+        return s->bar_no;
+    default:
+        qemu_epc_debug("BAR cfg read: detects unexpected read: 0x%lx\n",
+                       addr);
+    }
+
+    return 0;
+}
+
+static void qemu_epc_mmio_bar_cfg_write(void *opaque, hwaddr addr, uint64_t val,
+                                        unsigned size)
+{
+    QemuEPCState *s = opaque;
+    uint64_t tmp;
+
+    qemu_epc_debug("BAR cfg write: addr 0x%lx, size 0x%x\n", addr, size);
+
+    switch (addr) {
+    case QEMU_EPC_BAR_CFG_OFF_MASK:
+        s->bar_mask = (uint8_t)val;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_NUMBER:
+        s->bar_no = (uint8_t)val;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_FLAGS:
+        if (s->bar_no > 5) {
+            qemu_epc_debug("Selected BAR(%d) is invalid\n", s->bar_no);
+            break;
+        }
+        s->bars[s->bar_no].flags = (uint8_t)val;
+        s->pcie_cfg_space[PCI_BASE_ADDRESS_0 + s->bar_no * sizeof(uint32_t)]
+            = val;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_PHYS_ADDR:
+        if (s->bar_no > 5) {
+            qemu_epc_debug("Selected BAR(%d) is invalid\n", s->bar_no);
+            break;
+        }
+        if (size == sizeof(uint32_t)) {
+            tmp = (s->bars[s->bar_no].phys_addr & ~0xffffffffUL) | val;
+        } else if (size == sizeof(uint64_t)) {
+            tmp = val;
+        } else {
+            qemu_epc_debug("BAR cfg write: write size is invalid\n");
+            break;
+        }
+        s->bars[s->bar_no].phys_addr = tmp;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_PHYS_ADDR + sizeof(uint32_t):
+        if (s->bar_no > 5) {
+            qemu_epc_debug("Selected BAR(%d) is invalid\n", s->bar_no);
+            break;
+        }
+        if (size != sizeof(uint32_t)) {
+            qemu_epc_debug("BAR cfg write: write size is invalid\n");
+            break;
+        }
+        tmp = (s->bars[s->bar_no].phys_addr & 0xffffffffUL) | (val << 32);
+        s->bars[s->bar_no].phys_addr = tmp;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_SIZE:
+        if (s->bar_no > 5) {
+            qemu_epc_debug("Selected BAR(%d) is invalid\n", s->bar_no);
+            break;
+        }
+        if (size == sizeof(uint32_t)) {
+            tmp = (s->bars[s->bar_no].size & ~0xffffffffUL) | val;
+        } else if (size == sizeof(uint64_t)) {
+            tmp = val;
+        } else {
+            qemu_epc_debug("BAR cfg write: write size is invalid\n");
+            break;
+        }
+        s->bars[s->bar_no].size = tmp;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_SIZE + sizeof(uint32_t):
+        if (s->bar_no > 5) {
+            qemu_epc_debug("Selected BAR(%d) is invalid\n", s->bar_no);
+            break;
+        }
+
+        if (size != sizeof(uint32_t)) {
+            qemu_epc_debug("BAR cfg write: write size is invalid\n");
+            break;
+        }
+        tmp = (s->bars[s->bar_no].size & 0xffffffffUL) | (val << 32);
+        s->bars[s->bar_no].size = tmp;
+        break;
+    case QEMU_EPC_BAR_CFG_OFF_RSV:
+    default:
+        qemu_epc_debug("BAR cfg write: Detect invalid address: 0x%lx\n",
+                       addr);
+    }
+}
+
+static const MemoryRegionOps qemu_epc_mmio_bar_cfg_ops = {
+    .read = qemu_epc_mmio_bar_cfg_read,
+    .write = qemu_epc_mmio_bar_cfg_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+};
+
+static int qemu_epc_get_map_address(QemuEPCState *s, hwaddr phys, unsigned size,
+                                    hwaddr *pci)
+{
+    for (int i = 0; i < 32; i++) {
+        struct qemu_epc_ob_map *map = &s->ob_map[i];
+
+        if (phys < map->phys && phys >= map->phys + map->size) {
+            continue;
+        }
+
+        *pci = map->pci + phys - map->phys;
+        return 0;
+    }
+
+    return -1;
+}
+
+static uint64_t qemu_epc_mmio_ob_window_read(void *opaque, hwaddr addr,
+                                             unsigned size)
+{
+    QemuEPCState *s = opaque;
+    hwaddr phys = s->ob_window_mr.addr + addr;
+    hwaddr pci;
+    int err;
+    uint64_t data;
+
+    qemu_epc_debug("OB windows read: addr 0x%lx, size 0x%x\n", addr, size);
+
+    err = qemu_epc_get_map_address(s, phys, size, &pci);
+    if (err) {
+        qemu_epc_debug("detect invalid adress to read");
+        return 0;
+    }
+
+    err = qemu_epc_comm_mem_read(s->req_fd, pci, &data, size);
+    if (err) {
+        qemu_epc_debug("failed to request read");
+        return 0;
+    }
+
+    return data;
+}
+
+static void qemu_epc_mmio_ob_window_write(void *opaque, hwaddr addr,
+                                          uint64_t val, unsigned size)
+{
+    QemuEPCState *s = opaque;
+    hwaddr phys, pci;
+    int err;
+
+    qemu_epc_debug("OB windows write: addr 0x%lx, size 0x%x\n", addr, size);
+
+    phys = s->ob_window_mr.addr + addr;
+
+    err = qemu_epc_get_map_address(s, phys, size, &pci);
+    if (err) {
+        qemu_epc_debug("failed to walk outbounds map\n");
+        return;
+    }
+
+    err = qemu_epc_comm_mem_write(s->req_fd, pci, &val, size);
+    if (err) {
+        qemu_epc_debug("failed to write payload\n");
+    }
+}
+
+static const MemoryRegionOps qemu_epc_mmio_ob_window_ops = {
+    .read = qemu_epc_mmio_ob_window_read,
+    .write = qemu_epc_mmio_ob_window_write,
+    .endianness = DEVICE_LITTLE_ENDIAN,
+};
+
+static void qemu_epc_realize(PCIDevice *pci_dev, Error **errp)
+{
+    QemuEPCState *s = QEMU_EPC(pci_dev);
+
+    memory_region_init_io(&s->ctrl_mr, OBJECT(s), &qemu_epc_mmio_ctrl_ops, s,
+                          "qemu-epc/ctrl", pow2ceil(QEMU_EPC_CTRL_SIZE));
+    memory_region_init_io(&s->pci_cfg_mr, OBJECT(s), &qemu_epc_mmio_pci_cfg_ops,
+                          s, "qemu-epc/pci-cfg", PCIE_CONFIG_SPACE_SIZE);
+    memory_region_init_io(&s->bar_cfg_mr, OBJECT(s), &qemu_epc_mmio_bar_cfg_ops,
+                          s, "qemu-epc/bar-cfg",
+                          pow2ceil(QEMU_EPC_BAR_CFG_SIZE));
+    memory_region_init_io(&s->ob_window_mr, OBJECT(s),
+                          &qemu_epc_mmio_ob_window_ops, s, "qemu-epc/ob_window",
+                          QEMU_EPC_OB_WINDOW_SIZE);
+
+    pci_register_bar(pci_dev, QEMU_EPC_BAR_CTRL, PCI_BASE_ADDRESS_SPACE_MEMORY,
+                     &s->ctrl_mr);
+    pci_register_bar(pci_dev, QEMU_EPC_BAR_PCI_CFG,
+                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->pci_cfg_mr);
+    pci_register_bar(pci_dev, QEMU_EPC_BAR_BAR_CFG,
+                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->bar_cfg_mr);
+    pci_register_bar(pci_dev, QEMU_EPC_BAR_OB_WINDOW,
+                     PCI_BASE_ADDRESS_SPACE_MEMORY, &s->ob_window_mr);
+}
+
+static void qemu_epc_exit(PCIDevice *dev) {}
+
+static void qemu_epc_class_init(ObjectClass *klass, void *data)
+{
+    DeviceClass *dc = DEVICE_CLASS(klass);
+    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);
+
+    k->realize = qemu_epc_realize;
+    k->exit = qemu_epc_exit;
+    k->vendor_id = PCI_VENDOR_ID_REDHAT;
+    k->device_id = PCI_DEVICE_ID_REDHAT_QEMU_EPC;
+    k->revision = QEMU_EPC_REVISON;
+    k->class_id = PCI_CLASS_OTHERS;
+
+    dc->desc = "QEMU Endpoint Controller device";
+    set_bit(DEVICE_CATEGORY_MISC, dc->categories);
+}
+
+static const TypeInfo qemu_epc_info = {
+    .name = TYPE_QEMU_EPC,
+    .parent = TYPE_PCI_DEVICE,
+    .instance_size = sizeof(QemuEPCState),
+    .class_init = qemu_epc_class_init,
+    .interfaces = (InterfaceInfo[]){
+        {INTERFACE_CONVENTIONAL_PCI_DEVICE},
+        {}
+    },
+};
+
+static void qemu_epc_register_type(void)
+{
+    type_register_static(&qemu_epc_info);
+}
+
+type_init(qemu_epc_register_type);
diff --git a/include/hw/pci/pci.h b/include/hw/pci/pci.h
index fa6313aabc43..0c11a1a25867 100644
--- a/include/hw/pci/pci.h
+++ b/include/hw/pci/pci.h
@@ -115,6 +115,7 @@ extern bool pci_available;
 #define PCI_DEVICE_ID_REDHAT_PVPANIC     0x0011
 #define PCI_DEVICE_ID_REDHAT_ACPI_ERST   0x0012
 #define PCI_DEVICE_ID_REDHAT_UFS         0x0013
+#define PCI_DEVICE_ID_REDHAT_QEMU_EPC    0x0014
 #define PCI_DEVICE_ID_REDHAT_QXL         0x0100
 
 #define FMT_PCIBUS                      PRIx64
-- 
2.25.1

